import os, sys
import time
import sockets_server_api
import env
import signal
import sys
import threading
import math
from car_communication import messaging

# make parent directory available to import k8sapi
sys.path.insert(1, os.path.join(sys.path[0], '..'))
import k8sapi.api as k8sapi

# loads the traci lib path into the python load path so it can be imported
# https://github.com/wingsweihua/IntelliLight/blob/master/map_computor.py
if 'SUMO_HOME' in os.environ:
    tools = os.path.join(os.environ['SUMO_HOME'], 'tools')
    sys.path.append(tools)
else:
    sys.exit("please declare environment variable 'SUMO_HOME'")
import traci

# ----- global variables -----

# maps vehicle IDs to:
    #   "id": str,
    #   "pod_name": str,
    #   "LngLat": list[float],
    #   "rotateX": float,
    #   "rotateY": float,
    #   "rotateZ": float,
cars_info = {}
stop_all_sockets_connections = threading.Event()

# ----- functions definition -----
def get_current_time():
    return traci.simulation.getCurrentTime() / 1000


def getMapOfVehicles():
    vehicle_id_list = traci.vehicle.getIDList()
    vehicle_list = []

    for vehicle_id in vehicle_id_list:
        x, y, altitude = traci.vehicle.getPosition3D(vehicle_id)

        vehicle = {}
        vehicle["id"] = vehicle_id
        vehicle["position"] = [x, y]
        vehicle["altitude"] = altitude
        vehicle["speed"] = traci.vehicle.getSpeed(vehicle_id)
        vehicle["acceleration"] = traci.vehicle.getAcceleration(vehicle_id)
        vehicle["angle"] = traci.vehicle.getAngle(vehicle_id)
        vehicle["slope"] = traci.vehicle.getSlope(vehicle_id)
        vehicle_list.append(vehicle)
    
    return vehicle_list


def cleanup():
    '''Delete artifacts generated by the script (k8s namespace and pods) and close the traci and sockets APIs'''
    k8sapi.delete_namespace_pods(env.k8sapi_namespace, prefix="car-")
    traci.close()
    stop_all_sockets_connections.set()
    sockets_server.stop()


def signal_handler(sig, frame):
    ''''SIGINT (CTRL-C) handler'''
    print('\nYou pressed Ctrl+C!')

    cleanup()

    sys.exit(0)


# write to socket and receive response (can be ignored) on a loop
# when returns, socket connection is ended
def handle_CC_socket_connection(stream_request_handler, car_ID):
    global cars_info

    this_car_info = cars_info[car_ID]

    while True:
        if stop_all_sockets_connections.is_set():
            # leave it set for other handler threads
            stop_all_sockets_connections.set()
            break

        if this_car_info['wasUpdated'].is_set():
            this_car_info['wasUpdated'].clear()
            carData = messaging.exampleCarData
            carData['id'] = this_car_info['id']
            carData['LngLat'] = this_car_info['LngLat']
            carData["rotateX"] = this_car_info["rotateX"]
            carData["rotateY"] = this_car_info["rotateY"]
            carData["rotateZ"] = this_car_info["rotateZ"]

            messageEncoded = messaging.encodeMessage(carData, messaging.messageType.updateCarInfo)
            stream_request_handler.wfile.write(bytes(messageEncoded, "utf-8"))
            response = stream_request_handler.rfile.readline().strip().decode("utf-8")
            print(f"    {car_ID} wrote: {response}")
        
        time.sleep(0.001)
    
    return


# if pod_name is empty, doesn't update it
def create_or_update_car_info(vehicle):
    '''creates (if doesn't exist) or updates a car_info object based on the data of vehicle (returned by getMapOfVehicles)'''
    global cars_info

    car_info = {}

    if vehicle['id'] not in cars_info:
        new_pod_name = f"{env.car_pods_prefix}{len(cars_info)}"
        car_info["pod_name"] = new_pod_name
        car_info["wasUpdated"] = threading.Event()
    else:
        car_info = cars_info[vehicle['id']]

    car_info["id"] = vehicle['id']
    car_info["LngLat"] = vehicle['position']
    car_info["rotateX"] = 0
    car_info["rotateY"] = float(vehicle['angle']) * math.pi / 180
    car_info["rotateZ"] = 0
    car_info['wasUpdated'].set()

    cars_info[vehicle['id']] = car_info

    return car_info


# ----- main part -----
if __name__ == '__main__':
    sumoBinary = "/home/marcos/Proj/sumo/bin/sumo" #-gui
    sumoCmd = [sumoBinary, "-c", "/home/marcos/Proj/sumonetworks/quickstart/quickstart.sumocfg"]

    k8s_pod_image_name = "car_communication"
    k8s_pod_tag = "latest"

    pod_limit = 3

    signal.signal(signal.SIGINT, signal_handler)

    # if using GUI, stays here until you press play on the GUI
    traci.start(sumoCmd)
    k8sapi.load_api()

    sockets_server = sockets_server_api.Server(env.host, env.port, handle_CC_socket_connection)
    sockets_server.start()

    time.sleep(5)

    if env.running_kind:
        created = k8sapi.create_namespace_if_inexistent(env.k8sapi_namespace)
        if created:
            # sketchy hack hehe
            os.system(f"kubectl apply -f kind_localhost_fix.yaml --namespace={env.k8sapi_namespace}")

    for step in range(200):
        traci.simulationStep()

        print(f"iteration {step}:")
        vehicle_list = getMapOfVehicles()
        for vehicle in vehicle_list:
            if vehicle['id'] not in cars_info:
                if len(cars_info) < pod_limit:
                    # creates car info
                    new_car_info = create_or_update_car_info(vehicle)

                    k8sapi.create_pod(
                            new_car_info['pod_name'],
                            k8s_pod_image_name,
                            k8s_pod_tag,
                            envs={
                                "SERVER_ADDRESS": "dockerhost",
                                "SERVER_PORT": "9999",
                                "CAR_ID": new_car_info['id'],
                                "PYTHONUNBUFFERED": "1"
                            },
                            namespace=env.k8sapi_namespace)
            
            else:
                # updates car info
                create_or_update_car_info(vehicle)
            
            # try to run sumo with OSM data (and geolocation)

        time.sleep(0.1)
    
    # debugging sockets server
    # time.sleep(50)
    cleanup()